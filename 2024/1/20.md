## 取り組んだ課題一覧
- Udemy Go
- スターティング Goを読む

## わかったこと
- Git
  - `git checkout --orphan [branch]` 親コミットをもたないブランチを作成してチェックアウト
  - `git commit --allow-empty` 空のコミットを作成
  - リポジトリの作成の際にREADME.mdを作らないとmainブランチはデフォルトで作成されない
  - git branch -vv でアップストリーム（そのローカルブランチがどこのリモートブランチと紐付けされているか)を確認することができる

- Go
  - **構造体は値型**
  - newを用いると指定した型のポインタ型を生成してくれる
  - とある構造体のポインタ型pのNameフィールドにアクセスする場合、`n := (*p).Name`のように明示的にデリファレンスしなくても`n := p.Name`で自動的にデリファレンスしてくれる

## コードのメモ

```
type Point struct {
    X, Y float64
}

// 値レシーバを使ったメソッド
func (p Point) Distance() float64 {
    return math.Sqrt(p.X*p.X + p.Y*p.Y)
}

// ポインタレシーバを使ったメソッド
func (p *Point) Scale(s float64) {
    p.X = p.X * s
    p.Y = p.Y * s
}

func main() {
    p := Point{3, 4}
    distanceFunc := p.Distance   // メソッドへの参照を取得
    scaleFunc := (*Point).Scale  // メソッドへの参照を取得

    fmt.Println(distanceFunc())  // 5と表示される
    scaleFunc(&p, 2)             // pをスケールする
    fmt.Println(p)               // {6 8}と表示される
}
```

### メソッドへの参照を取得する時
- レシーバが値型だった場合：
```
値を作成して変数に代入してその変数.メソッド名の形でメソッドの参照を取り出すことができる。
レシーバにはその値のコピーがバインドされている。
```
- レシーバがポインタだった場合：
```
レシーバは暗黙的にそのメソッド（関数）の第一引数として渡されるという性質から、
メソッドの参照を変数に代入して関数のように扱うときは、その関数の第一引数にレシーバーを渡す必要がある。
```

## 次やること
- Udemy Go
- スターティングGoを読む

## 感じたこと
- Goに時間を使えて嬉しい。
- 引き続きGoメインかつ、ロードマップもJSからどんどん取り組んでいきたい。

## 学習時間　
- Today：6h15m
- Total：268h45m
